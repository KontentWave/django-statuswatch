# Endpoint Monitoring (CRUD) â€” Implementation Detail

## Overview

Authenticated tenants manage their monitored URLs through `/api/endpoints/` and the `/dashboard` UI. The feature supports listing, creating, and deleting endpoint monitors while enforcing tenant isolation and kicking off asynchronous health checks.

## Frontend Implementation

- **Routing:** `frontend/src/app/router.tsx` declares `/dashboard` beneath the `authenticated` route. The guard verifies a stored access token and redirects unauthenticated users to `/login` with context.
- **Data Fetching:** `DashboardPage` (`frontend/src/pages/Dashboard.tsx`) uses TanStack Query to call `listEndpoints({ page })`. Pagination keeps previous data to avoid UI flicker and trims the page index when a delete empties the current slice.
- **Presentation:** `EndpointTable` (`frontend/src/components/EndpointTable.tsx`) renders the dataset via TanStack Table with stable `getRowId` mapping to endpoint UUIDs. Table controls invoke `onPageChange`, and the component logs success/error pagination events through `logDashboardEvent`.
- **Mutations:** `createEndpoint` and `deleteEndpoint` mutations live in `DashboardPage`. Creation resets the form and invalidates the endpoints query; deletion invalidates and keeps UI state consistent with `page` and `pageSizeRef`.
- **API Client:** `frontend/src/lib/endpoint-client.ts` wraps Axios calls, injects lightweight request IDs, and emits structured logs via `endpoint-logger` helpers.
- **Tests:** `frontend/src/pages/__tests__/DashboardPage.test.tsx` covers happy-path list rendering, pagination transitions, create/delete flows, auth guard redirect on 401, logout mutations, and error messaging.

## Backend Implementation

- **Data Model:** `backend/monitors/models.py` defines `Endpoint` with a UUID primary key, `tenant` FK, URL metadata, last status fields, and uniqueness constraint scoped to each tenant.
- **Serialization:** `EndpointSerializer` (`backend/monitors/serializers.py`) exposes monitor fields plus a read-only `tenant_name`. It validates interval bounds (1 minute to 24 hours).
- **API Surface:** `EndpointViewSet` (`backend/monitors/views.py`) provides CRUD operations. `get_queryset` filters by `request.tenant`, `perform_create` stamps audit logs, records enqueue time, and schedules the first ping, while `perform_destroy` records audit entries before deletion.
- **URLs:** `backend/monitors/urls.py` registers the viewset with DRF's router; `backend/app/urls_tenant.py` includes the router at `/api/endpoints/` alongside auth routes.

## Background Jobs

- **Ping Execution:** `ping_endpoint` Celery task issues a timed HTTP GET, records latency/status, retries network failures, and logs structured events for auditing/performance tracking.
- **Scheduling:** `schedule_endpoint_checks` iterates tenant schemas (via `django-tenants`) and enqueues due monitors based on `interval_minutes`, updating `last_enqueued_at` to avoid duplicate scheduling.

## Testing

- **API Tests:** `backend/monitors/tests/test_endpoints_api.py` verifies auth enforcement, tenant isolation, create/list/delete flows, and ensures create enqueues a ping.
- **Scheduler Tests:** `backend/monitors/tests/test_scheduler.py` asserts due calculation, enqueue behavior, and schema handling for the periodic scheduler task.
- **Frontend Tests:** Vitest suite (`frontend/src/pages/__tests__/DashboardPage.test.tsx`) mocks API clients to confirm UI reactions to CRUD events and pagination logging.

## Operational Notes

- Audit and performance logs write to the `monitors.*` logger namespace, enabling routing to dedicated files or observability sinks.
- Endpoint creation triggers an immediate Celery task; ensure workers share the same code and environment (requests timeout, Redis broker) as the Django app.
