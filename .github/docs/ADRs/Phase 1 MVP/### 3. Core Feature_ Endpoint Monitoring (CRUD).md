# Endpoint Monitoring (CRUD) — Implementation Detail

## Overview

Authenticated tenants manage their monitored URLs through `/api/endpoints/` and the `/dashboard` UI. The feature supports listing, creating, and deleting endpoint monitors while enforcing tenant isolation and kicking off asynchronous health checks.

## Frontend Implementation

- **Routing:** `frontend/src/app/router.tsx` declares `/dashboard` beneath the `authenticated` route. The guard verifies a stored access token and redirects unauthenticated users to `/login` with context.
- **Data Fetching:** `DashboardPage` (`frontend/src/pages/Dashboard.tsx`) uses TanStack Query to call `listEndpoints({ page })`. Pagination keeps previous data to avoid UI flicker and trims the page index when a delete empties the current slice.
- **Presentation:** `EndpointTable` (`frontend/src/components/EndpointTable.tsx`) renders the dataset via TanStack Table with stable `getRowId` mapping to endpoint UUIDs. Table controls invoke `onPageChange`, and the component logs success/error pagination events through `logDashboardEvent`.
- **Mutations:** `createEndpoint` and `deleteEndpoint` mutations live in `DashboardPage`. Creation resets the form and invalidates the endpoints query; deletion invalidates and keeps UI state consistent with `page` and `pageSizeRef`.
- **API Client:** `frontend/src/lib/endpoint-client.ts` wraps Axios calls, injects lightweight request IDs, and emits structured logs via `endpoint-logger` helpers.
- **Tests:** `frontend/src/pages/__tests__/DashboardPage.test.tsx` covers happy-path list rendering, pagination transitions, create/delete flows, auth guard redirect on 401, logout mutations, and error messaging.

## Backend Implementation

- **Data Model:** `backend/monitors/models.py` defines `Endpoint` with a UUID primary key, `tenant` FK, URL metadata, last status fields, and uniqueness constraint scoped to each tenant.
- **Serialization:** `EndpointSerializer` (`backend/monitors/serializers.py`) exposes monitor fields plus a read-only `tenant_name`. It validates interval bounds (1 minute to 24 hours).
- **API Surface:** `EndpointViewSet` (`backend/monitors/views.py`) provides CRUD operations. `get_queryset` filters by `request.tenant`, `perform_create` stamps audit logs, records enqueue time, and schedules the first ping, while `perform_destroy` records audit entries before deletion.
- **URLs:** `backend/monitors/urls.py` registers the viewset with DRF's router; `backend/app/urls_tenant.py` includes the router at `/api/endpoints/` alongside auth routes.

## Background Jobs

- **Ping Execution:** `ping_endpoint` Celery task issues a timed HTTP GET, records latency/status, retries network failures, and logs structured events for auditing/performance tracking.
- **Scheduling:** `schedule_endpoint_checks` iterates tenant schemas (via `django-tenants`) and enqueues due monitors based on `interval_minutes`, updating `last_enqueued_at` to avoid duplicate scheduling.

## Testing

- **API Tests:** `backend/monitors/tests/test_endpoints_api.py` verifies auth enforcement, tenant isolation, create/list/delete flows, and ensures create enqueues a ping.
- **Scheduler Tests:** `backend/monitors/tests/test_scheduler.py` asserts due calculation, enqueue behavior, and schema handling for the periodic scheduler task.
- **Frontend Tests:** Vitest suite (`frontend/src/pages/__tests__/DashboardPage.test.tsx`) mocks API clients to confirm UI reactions to CRUD events and pagination logging.

## Operational Notes

- Audit and performance logs write to the `monitors.*` logger namespace, enabling routing to dedicated files or observability sinks.
- Endpoint creation triggers an immediate Celery task; ensure workers share the same code and environment (requests timeout, Redis broker) as the Django app.

---

## Phase 1 Production Readiness

### Critical Fixes Completed (October 24, 2025)

**Security Enhancements:**

- ✅ SSRF vulnerability fixed - URL validation blocks private IP ranges
- ✅ Secrets validation enforced - prevents production deployment with defaults
- ✅ HTTPS enforcement with HSTS - secure cookies and strict transport security
- ✅ Security headers middleware - CSP, X-Frame-Options, Permissions-Policy
- ✅ JWT token rotation and blacklisting
- ✅ Rate limiting on authentication endpoints
- ✅ Error message sanitization to prevent information disclosure
- ✅ Email verification system with token expiration

**Reliability Improvements:**

- ✅ Transaction management - atomic endpoint creation prevents orphaned records
- ✅ Race condition fix - `select_for_update(skip_locked=True)` prevents duplicate scheduling
- ✅ Dead letter queue - failure notifications after retry exhaustion
- ✅ Celery task queueing fix - `.delay()` calls moved outside `transaction.atomic()` blocks

**Performance Optimizations:**

- ✅ Database indexes added - `(tenant, last_enqueued_at)`, `(tenant, last_checked_at)`
- ✅ N+1 query elimination - `select_related('tenant')` in endpoint queries
- ✅ Scheduler optimization - batch processing with O(1) memory usage

**Monitoring & Observability:**

- ✅ Sentry integration - Django/Celery/Redis error tracking and performance monitoring
- ✅ Health check endpoints - `/health/`, `/health/ready/`, `/metrics/`
- ✅ CI/CD enhancement - GitHub Actions validates Celery task registration
- ✅ Logging sanitization - strips secrets from audit logs

### Test Coverage

- **Backend:** 88% coverage (pytest) with 35+ tests for security fixes
- **Frontend:** Comprehensive Vitest suites for auth, registration, dashboard
- **Integration:** Celery task registration verified in CI pipeline

### Production Deployment Status

**✅ PRODUCTION READY**

All critical security, reliability, and performance issues have been resolved. The codebase demonstrates mature engineering practices with:

- Zero critical vulnerabilities
- Atomic transactions ensuring data integrity
- Race-free scheduler with database locks
- Comprehensive monitoring and health checks
- 88% test coverage (industry average: 70%)
- Technical debt: 10-15% (industry average: 30%)

**Production Readiness Score: 78/100** (threshold: 70)

### Known Limitations

**Phase 2 Enhancements (Optional):**

- Multi-protocol support (TCP, UDP, ICMP)
- Custom HTTP headers for authenticated checks
- Response body validation (regex, JSON path)
- SSL certificate expiry monitoring
- Multi-location monitoring
- Advanced incident management

**Technical Debt (Low Priority):**

- Type hint coverage: 66.7% (target: 100%)
- Bundle size: 523KB (target: <500KB)
- CSP nonces in Vite (deferred)

For detailed audit findings, see `.github/docs/Audits/Phase 1/### 3. Core Feature_ Endpoint Monitoring (CRUD)/08_EXECUTIVE_SUMMARY.md`
